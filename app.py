# app.py
import streamlit as st
import time
import threading
import os
import datetime
import queue # Importa o m√≥dulo queue

# Importa as classes e servi√ßos de dentro do seu pacote src
from src.services.simulation import PaymentSimulator

# --- Configura√ß√µes Iniciais ---
output_dir = "data/output"
if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Configura√ß√µes de logging para o console (ainda √∫til para depura√ß√£o interna)
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

logger.info("app.py: Script iniciado.")

st.set_page_config(
    page_title="Simulador de Fluxo de Pagamentos",
    page_icon="üí≥",
    layout="wide"
)

# --- T√≠tulo e Descri√ß√£o da Aplica√ß√£o ---
st.title("üí≥ Simulador de Fluxo de Pagamentos Detalhado")
st.write("Este aplicativo simula o complexo fluxo de transa√ß√µes financeiras, incluindo **autoriza√ß√£o**, **captura**, **liquida√ß√£o**, **faturamento**, **pagamento ao lojista**, **relat√≥rios regulat√≥rios** e, agora, o intrincado processo de **chargeback**.")

# --- Inicializa√ß√£o do Estado da Sess√£o do Streamlit ---
if 'log_messages' not in st.session_state:
    st.session_state.log_messages = ["Clique em 'Iniciar Simula√ß√£o' para come√ßar..."]
    logger.info("app.py: st.session_state.log_messages inicializado.")
if 'simulation_running' not in st.session_state:
    st.session_state.simulation_running = False
    logger.info("app.py: st.session_state.simulation_running inicializado.")
if 'thread_finished' not in st.session_state:
    st.session_state.thread_finished = False
    logger.info("app.py: st.session_state.thread_finished inicializado.")

# --- NOVO: Inicializa a fila de logs Fora do st.session_state, mas a armazena para passar.
# A fila ser√° acessada diretamente pela callback, n√£o via st.session_state nela.
# Isso garante que a fila exista e seja acess√≠vel desde o in√≠cio.
if 'log_queue' not in st.session_state: # Mantenha no session_state para persist√™ncia
    st.session_state.log_queue = queue.Queue()
    logger.info("app.py: st.session_state.log_queue inicializado.")

# --- Placeholders para Atualiza√ß√µes Din√¢micas na UI ---
status_placeholder = st.empty()
log_placeholder = st.empty()

# --- Callback para Enviar Logs da Simula√ß√£o para a FILA (na thread secund√°ria) ---
# AGORA RECEBE A FILA DIRETAMENTE COMO ARGUMENTO
def streamlit_log_callback(q: queue.Queue, message: str, color_tag: str = "black"):
    color_map = {
        "white": "black", "blue": "#1E90FF", "green": "#32CD32",
        "red": "#FF4500", "yellow": "#FFD700", "magenta": "#DA70D6",
        "lightblue": "#ADD8E6", "black": "black",
    }
    html_color = color_map.get(color_tag, "black")
    
    try:
        q.put(f"<span style='color: {html_color};'>{message}</span>")
        logger.debug(f"app.py: Mensagem colocada na fila: {message}")
    except Exception as e:
        # Erros aqui s√£o mais prov√°veis de serem problemas na pr√≥pria fila
        logger.error(f"app.py: Erro ao colocar log na fila: {e}", exc_info=True)


# --- Fun√ß√£o para Rodar a Simula√ß√£o em uma Thread Separada ---
# AGORA PASSA A FILA E A FUN√á√ÉO DE CALLBACK
def run_simulation_in_thread_target(log_queue_ref: queue.Queue, log_callback_func, output_dir_path):
    logger.info("app.py: Thread de simula√ß√£o iniciada.")
    try:
        # Passa a fun√ß√£o de callback e a fila de logs para o simulador
        # A PaymentSimulator agora ter√° acesso √† fila via o callback
        simulator = PaymentSimulator(output_dir=output_dir_path, log_callback=lambda msg, color: log_callback_func(log_queue_ref, msg, color))
        simulator.run_full_simulation()
    except Exception as e:
        # Se ocorrer um erro cr√≠tico na simula√ß√£o, registre-o na fila
        log_callback_func(log_queue_ref, f"ERRO CR√çTICO NA SIMULA√á√ÉO (THREAD): {e}", "red") # Passa a fila
        logger.error(f"app.py: Erro na thread de simula√ß√£o: {e}", exc_info=True)
    finally:
        st.session_state.thread_finished = True
        logger.info("app.py: st.session_state.thread_finished definido como True.")


# --- L√≥gica Principal do Streamlit App ---
logger.info(f"app.py: In√≠cio da l√≥gica principal. simulation_running: {st.session_state.simulation_running}")

# Bot√£o Iniciar/Reiniciar Simula√ß√£o
if st.button("Iniciar Simula√ß√£o", disabled=st.session_state.simulation_running):
    logger.info("app.py: Bot√£o 'Iniciar Simula√ß√£o' clicado.")
    st.session_state.simulation_running = True
    st.session_state.log_messages = [] # Limpa o log ao iniciar
    st.session_state.thread_finished = False # Reseta o flag da thread
    
    # Limpa a fila ao iniciar uma nova simula√ß√£o
    with st.session_state.log_queue.mutex:
        st.session_state.log_queue.queue.clear()
    
    log_placeholder.empty()
    status_placeholder.empty()
    
    # Passa a REFER√äNCIA da fila para a thread
    thread = threading.Thread(target=run_simulation_in_thread_target, 
                              args=(st.session_state.log_queue, streamlit_log_callback, output_dir))
    thread.start()
    logger.info("app.py: Thread de simula√ß√£o disparada.")

# --- Loop de Atualiza√ß√£o de Logs na Thread Principal ---
if st.session_state.simulation_running:
    logger.info("app.py: Entrando no loop de atualiza√ß√£o de logs.")
    status_placeholder.info("Simula√ß√£o em andamento...")
    
    while not st.session_state.thread_finished or not st.session_state.log_queue.empty():
        while not st.session_state.log_queue.empty():
            try:
                message = st.session_state.log_queue.get_nowait()
                st.session_state.log_messages.append(message)
                logger.debug(f"app.py: Mensagem pega da fila: {message[:50]}...")
            except queue.Empty:
                break
            except Exception as e:
                logger.error(f"app.py: Erro ao pegar log da fila: {e}", exc_info=True)
                break

        current_log_content = "<br>".join(st.session_state.log_messages)
        log_placeholder.markdown(current_log_content, unsafe_allow_html=True)
        
        time.sleep(0.1)

    logger.info("app.py: Saindo do loop de atualiza√ß√£o de logs.")
    final_log_content = "<br>".join(st.session_state.log_messages)
    log_placeholder.markdown(final_log_content, unsafe_allow_html=True)
    
    status_placeholder.success("Simula√ß√£o conclu√≠da! Verifique a pasta `data/output/` para os arquivos gerados.")
    st.session_state.simulation_running = False
    st.session_state.thread_finished = False
    logger.info("app.py: Simula√ß√£o conclu√≠da e estado resetado.")

else:
    initial_log_content = "<br>".join(st.session_state.log_messages)
    log_placeholder.markdown(initial_log_content, unsafe_allow_html=True)
    logger.info("app.py: Exibindo log inicial/final.")


# --- Barra Lateral com Informa√ß√µes Adicionais ---
st.sidebar.header("Informa√ß√µes")
st.sidebar.write("Os arquivos gerados durante a simula√ß√£o (captura, liquida√ß√£o, CNAB, regulat√≥rios, etc.) ser√£o salvos na pasta **`data/output/`** do seu ambiente.")
st.sidebar.markdown("""
    ---
    Desenvolvido para fins **did√°ticos**.
    Simula um ecossistema de pagamentos para ilustrar a intera√ß√£o
    entre Estabelecimentos, Portadores, Adquirentes, Bandeiras, Emissores e o Banco Central.
    """)
logger.info("app.py: Script finalizado (renderiza√ß√£o do Streamlit).")
